<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>commander.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="commands.html">commands</a></li><li><a href="commands.validation.html">validation</a><ul class='methods'><li data-type='method'><a href="commands.validation.html#.and">and</a></li><li data-type='method'><a href="commands.validation.html#.isIdentifier">isIdentifier</a></li><li data-type='method'><a href="commands.validation.html#.makeNumber">makeNumber</a></li><li data-type='method'><a href="commands.validation.html#.makeOptions">makeOptions</a></li><li data-type='method'><a href="commands.validation.html#.makeType">makeType</a></li></ul></li><li><a href="physical.html">physical</a></li><li><a href="selectors.html">selectors</a></li><li><a href="trafficLight.html">trafficLight</a></li></ul><h3>Classes</h3><ul><li><a href="Commander.html">Commander</a><ul class='methods'><li data-type='method'><a href="Commander.html#.multi">multi</a></li><li data-type='method'><a href="Commander.html#.single">single</a></li><li data-type='method'><a href="Commander.html#cancel">cancel</a></li><li data-type='method'><a href="Commander.html#close">close</a></li><li data-type='method'><a href="Commander.html#help">help</a></li><li data-type='method'><a href="Commander.html#logInfo">logInfo</a></li><li data-type='method'><a href="Commander.html#run">run</a></li><li data-type='method'><a href="Commander.html#runDefinitions">runDefinitions</a></li><li data-type='method'><a href="Commander.html#runDefinitionsFile">runDefinitionsFile</a></li><li data-type='method'><a href="Commander.html#runFile">runFile</a></li></ul></li><li><a href="commands.Cancellable.html">Cancellable</a><ul class='methods'><li data-type='method'><a href="commands.Cancellable.html#add">add</a></li><li data-type='method'><a href="commands.Cancellable.html#cancel">cancel</a></li><li data-type='method'><a href="commands.Cancellable.html#del">del</a></li></ul></li><li><a href="commands.CodeFormatter.html">CodeFormatter</a><ul class='methods'><li data-type='method'><a href="commands.CodeFormatter.html#format">format</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatCommand">formatCommand</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatComment">formatComment</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatIdentifier">formatIdentifier</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatNumber">formatNumber</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatParens">formatParens</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatSpace">formatSpace</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatString">formatString</a></li><li data-type='method'><a href="commands.CodeFormatter.html#formatVariable">formatVariable</a></li></ul></li><li><a href="commands.Interpreter.html">Interpreter</a><ul class='methods'><li data-type='method'><a href="commands.Interpreter.html#add">add</a></li><li data-type='method'><a href="commands.Interpreter.html#cancel">cancel</a></li><li data-type='method'><a href="commands.Interpreter.html#execute">execute</a></li><li data-type='method'><a href="commands.Interpreter.html#executeFile">executeFile</a></li><li data-type='method'><a href="commands.Interpreter.html#lookup">lookup</a></li></ul></li><li><a href="commands.MetaFormatter.html">MetaFormatter</a><ul class='methods'><li data-type='method'><a href="commands.MetaFormatter.html#format">format</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatBlockTag">formatBlockTag</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatCode">formatCode</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatDesc">formatDesc</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatInlineCode">formatInlineCode</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatInlineTag">formatInlineTag</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatName">formatName</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatParam">formatParam</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatParams">formatParams</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatReturn">formatReturn</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatSignature">formatSignature</a></li><li data-type='method'><a href="commands.MetaFormatter.html#formatTextBlock">formatTextBlock</a></li></ul></li><li><a href="physical.Device.html">Device</a><ul class='methods'><li data-type='method'><a href="physical.Device.html#connect">connect</a></li><li data-type='method'><a href="physical.Device.html#disconnect">disconnect</a></li><li data-type='method'><a href="physical.Device.html#turn">turn</a></li></ul></li><li><a href="physical.DeviceManager.html">DeviceManager</a><ul class='methods'><li data-type='method'><a href="physical.DeviceManager.html#allDevices">allDevices</a></li><li data-type='method'><a href="physical.DeviceManager.html#info">info</a></li><li data-type='method'><a href="physical.DeviceManager.html#logInfo">logInfo</a></li><li data-type='method'><a href="physical.DeviceManager.html#startMonitoring">startMonitoring</a></li><li data-type='method'><a href="physical.DeviceManager.html#stopMonitoring">stopMonitoring</a></li><li data-type='method'><a href="physical.DeviceManager.html#supportsMonitoring">supportsMonitoring</a></li></ul></li><li><a href="physical.NullUsbDetector.html">NullUsbDetector</a><ul class='methods'><li data-type='method'><a href="physical.NullUsbDetector.html#on">on</a></li><li data-type='method'><a href="physical.NullUsbDetector.html#startMonitoring">startMonitoring</a></li><li data-type='method'><a href="physical.NullUsbDetector.html#stopMonitoring">stopMonitoring</a></li><li data-type='method'><a href="physical.NullUsbDetector.html#supportsMonitoring">supportsMonitoring</a></li></ul></li><li><a href="physical.PhysicalLight.html">PhysicalLight</a><ul class='methods'><li data-type='method'><a href="physical.PhysicalLight.html#sync">sync</a></li><li data-type='method'><a href="physical.PhysicalLight.html#toggle">toggle</a></li><li data-type='method'><a href="physical.PhysicalLight.html#turnOff">turnOff</a></li><li data-type='method'><a href="physical.PhysicalLight.html#turnOn">turnOn</a></li></ul></li><li><a href="physical.PhysicalTrafficLight.html">PhysicalTrafficLight</a><ul class='methods'><li data-type='method'><a href="physical.PhysicalTrafficLight.html#checkIn">checkIn</a></li><li data-type='method'><a href="physical.PhysicalTrafficLight.html#checkOut">checkOut</a></li><li data-type='method'><a href="physical.PhysicalTrafficLight.html#reset">reset</a></li><li data-type='method'><a href="physical.PhysicalTrafficLight.html#sync">sync</a></li></ul></li><li><a href="physical.UsbDetector.html">UsbDetector</a><ul class='methods'><li data-type='method'><a href="physical.UsbDetector.html#on">on</a></li><li data-type='method'><a href="physical.UsbDetector.html#startMonitoring">startMonitoring</a></li><li data-type='method'><a href="physical.UsbDetector.html#stopMonitoring">stopMonitoring</a></li><li data-type='method'><a href="physical.UsbDetector.html#supportsMonitoring">supportsMonitoring</a></li></ul></li><li><a href="selectors.PhysicalMultiTrafficLightSelector.html">PhysicalMultiTrafficLightSelector</a><ul class='methods'><li data-type='method'><a href="selectors.PhysicalMultiTrafficLightSelector.html#close">close</a></li><li data-type='method'><a href="selectors.PhysicalMultiTrafficLightSelector.html#logInfo">logInfo</a></li><li data-type='method'><a href="selectors.PhysicalMultiTrafficLightSelector.html#resolveTrafficLight">resolveTrafficLight</a></li></ul></li><li><a href="selectors.PhysicalTrafficLightSelector.html">PhysicalTrafficLightSelector</a><ul class='methods'><li data-type='method'><a href="selectors.PhysicalTrafficLightSelector.html#close">close</a></li><li data-type='method'><a href="selectors.PhysicalTrafficLightSelector.html#logInfo">logInfo</a></li><li data-type='method'><a href="selectors.PhysicalTrafficLightSelector.html#resolveTrafficLight">resolveTrafficLight</a></li></ul></li><li><a href="trafficLight.FlexMultiTrafficLight.html">FlexMultiTrafficLight</a><ul class='methods'><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#add">add</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#checkIn">checkIn</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#checkOut">checkOut</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#last">last</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#near">near</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#next">next</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#previous">previous</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#reset">reset</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#use">use</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#useAll">useAll</a></li><li data-type='method'><a href="trafficLight.FlexMultiTrafficLight.html#using">using</a></li></ul></li><li><a href="trafficLight.Light.html">Light</a><ul class='methods'><li data-type='method'><a href="trafficLight.Light.html#toggle">toggle</a></li><li data-type='method'><a href="trafficLight.Light.html#turnOff">turnOff</a></li><li data-type='method'><a href="trafficLight.Light.html#turnOn">turnOn</a></li></ul></li><li><a href="trafficLight.MultiLight.html">MultiLight</a><ul class='methods'><li data-type='method'><a href="trafficLight.MultiLight.html#toggle">toggle</a></li><li data-type='method'><a href="trafficLight.MultiLight.html#turnOff">turnOff</a></li><li data-type='method'><a href="trafficLight.MultiLight.html#turnOn">turnOn</a></li></ul></li><li><a href="trafficLight.MultiTrafficLight.html">MultiTrafficLight</a><ul class='methods'><li data-type='method'><a href="trafficLight.MultiTrafficLight.html#checkIn">checkIn</a></li><li data-type='method'><a href="trafficLight.MultiTrafficLight.html#checkOut">checkOut</a></li><li data-type='method'><a href="trafficLight.MultiTrafficLight.html#reset">reset</a></li></ul></li><li><a href="trafficLight.TrafficLight.html">TrafficLight</a><ul class='methods'><li data-type='method'><a href="trafficLight.TrafficLight.html#checkIn">checkIn</a></li><li data-type='method'><a href="trafficLight.TrafficLight.html#checkOut">checkOut</a></li><li data-type='method'><a href="trafficLight.TrafficLight.html#reset">reset</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">commander.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>////////////////////////////////////////////////

const fs = require('fs');
const util = require('util');

////////////////////////////////////////////////

function tryRequire(path) {
  try {
    return require(path);
  } catch (e) {
    return {};
  }
}

////////////////////////////////////////////////

// The default Selector constructor.
// This is an optional requirement since when used in a web context
// it would fail because of further USB-related dependencies.
// Browserify won't pick it up since the `require` call is encapsulated in `tryRequire`.
// If DefaultSelectorCtor is null, then it's a mandatory option to the Commander ctor.
const DefaultSelectorCtor = tryRequire('./selectors/physical-traffic-light-selector').SelectorCtor;

////////////////////////////////////////////////

function makeDefaultInterpreter() {
  const {Interpreter} = require('./commands/interpreter');
  const interpreter = new Interpreter();
  // define all commands
  require('./traffic-light/traffic-light-commands').defineCommands(interpreter);
  require('./traffic-light/multi-traffic-light-commands').defineCommands(interpreter);
  return interpreter;
}

////////////////////////////////////////////////

function makeDefaultFormatter() {
  const {MetaFormatter} = require('./commands/meta-formatter');
  return new MetaFormatter();
}

////////////////////////////////////////////////

/**
 * Issues commands to control a traffic light.
 */
class Commander {

  /**
   * Creates a new Commander instance.
   * @param {object} [options] - Commander options.
   * @param {object} [options.logger=console] - A Console-like object for logging,
   *   with a log and an error function.
   * @param {commands.MetaFormatter} [options.formatter] - A formatter for the help text of
   *   a command.
   * @param {commands.Interpreter} [options.interpreter] - The Command Interpreter to use.
   * @param {object} [options.selector] - The traffic light selector to use.
   *   Takes precedence over `options.SelectorCtor`.
   * @param {function} [options.SelectorCtor] - The constructor of a traffic
   *   light selector to use. Will be passed the entire `options` object.
   *   Ignored if `options.selector` is set.
   */
  constructor(options = {}) {
    let {
      logger = console,
      formatter = makeDefaultFormatter(),
      interpreter = makeDefaultInterpreter(),
      selector = null,
      SelectorCtor = DefaultSelectorCtor
    } = options;
    this.logger = logger;
    this.formatter = formatter;
    this.interpreter = interpreter;
    this.selector = selector || new SelectorCtor(options);
    this.selector.on('enabled', () => this._resumeIfNeeded());
    this.selector.on('disabled', () => this.cancel());
    this.selector.on('interrupted', () => this._interrupt());
  }

  /**
   * Called to close this instance.
   * Should be done as the last operation before exiting the process.
   */
  close() {
    this.selector.close();
  }

  /**
   * Cancels any currently executing command.
   */
  cancel() {
    this.interpreter.cancel();
  }

  _interrupt() {
    if (!this.running) return;
    this.isInterrupted = true;
    this.interpreter.cancel();
  }

  /**
   * Executes a file with command definitions asynchronously.
   * @param {string} filePath - Path to the file to execute.
   *   Should only contain command definitions (`define` or `def`).
   * @param {string} [encoding='utf8'] - Encoding of the file.
   */
  async runDefinitionsFile(filePath, encoding = 'utf8') {
    let command = await this._readFile(filePath, encoding);
    if (command) return this.runDefinitions(command);
  }

  /**
   * Executes a command with definitions asynchronously.
   * @param {string} command - Command to execute. Should only contain command
   *   definitions (`define` or `def`).
   */
  async runDefinitions(command) {
    try {
      this.logger.log('running definitions');
      await this.interpreter.execute(command); // no context, only for definitions
      this.logger.log('finished definitions');
    } catch (e) {
      this.logger.error('error in definitions');
      this.logger.error(e.message);
    }
  }

  /**
   * Executes a command file asynchronously.
   * If the same command is already running, does nothing.
   * If another command is running, cancels it, resets the traffic light,
   * and runs the new command.
   * If no command is running, executes the given command, optionally
   * resetting the traffic light based on the `reset` parameter.
   * If there's no traffic light to run the command, stores it for later when
   * one becomes available. Logs messages appropriately.
   * @param {string} filePath - Path to the file to execute.
   * @param {boolean} [reset=false] - Whether to reset the traffic light
   *   before executing the command.
   * @param {string} [encoding='utf8'] - Encoding of the file.
   */
  async runFile(filePath, reset = false, encoding = 'utf8') {
    let command = await this._readFile(filePath, encoding);
    if (command) return this.run(command, reset);
  }

  async _readFile(filePath, encoding) {
    try {
      if (!fs.readFileAsync) fs.readFileAsync = util.promisify(fs.readFile);
      return await fs.readFileAsync(filePath, encoding);
    } catch (e) {
      this.logger.error(`error accessing file '${filePath}'`);
      this.logger.error(e.message);
      return null;
    }
  }

  /**
   * Executes a command asynchronously.
   * If the same command is already running, does nothing.
   * If another command is running, cancels it, resets the traffic light,
   * and runs the new command.
   * If no command is running, executes the given command, optionally
   * resetting the traffic light based on the `reset` parameter.
   * If there's no traffic light to run the command, stores it for later when
   * one becomes available. Logs messages appropriately.
   * @param {string} command - Command to execute.
   * @param {boolean} [reset=false] - Whether to reset the traffic light
   *   before executing the command.
   */
  async run(command, reset = false) {
    let tl = this.selector.resolveTrafficLight();
    if (!tl) {
      this.suspended = command;
      this.logger.log('no traffic light available');
      return;
    }
    try {
      if (this._skipIfRunningSame(command, tl)) return;
      await this._cancelIfRunningDifferent(command, tl);
      return await this._execute(command, tl, reset);
    } catch (e) {
      this._errorInExecution(command, tl, e);
    }
  }

  async _cancelIfRunningDifferent(command, tl) {
    if (!this.running || this.running === command) return;
    this.interpreter.cancel();
    await tl.reset();
  }

  _skipIfRunningSame(command, tl) {
    if (this.running !== command) return false;
    return true;
  }

  async _execute(command, tl, reset) {
    if (reset) await tl.reset();
    this.logger.log(`${tl}: running`);
    this.running = command;
    let res = await this.interpreter.execute(command, {tl});
    if (command === this.running) this.running = null;
    this._finishedExecution(command, tl);
    return res;
  }

  _finishedExecution(command, tl) {
    if (this.isInterrupted || !tl.isEnabled) {
      let state = this.isInterrupted ? 'interrupted' : 'disabled';
      this.logger.log(`${tl}: ${state}, suspending running command`);
      this.suspended = command;
      this.isInterrupted = false;
      this._resumeIfNeeded(); // try to resume in another traffic light
    } else {
      this.suspended = null;
      this.logger.log(`${tl}: finished`);
    }
  }

  _errorInExecution(command, tl, error) {
    if (command === this.running) this.running = null;
    this.logger.error(`${tl}: error in command`);
    this.logger.error(error.message);
  }

  _resumeIfNeeded() {
    let command = this.suspended;
    if (!command) return;
    this.suspended = null;
    this.run(command, true); // no await
  }

  /**
   * All supported command names.
   * @type {string[]}
   */
  get commandNames() {
    return this.interpreter.commandNames;
  }

  /**
   * All supported commands indexed by their names.
   * @type {object.&lt;string, commands.Command>}
   */
  get commands() {
    return this.interpreter.commands;
  }

  /**
   * Logs the help info for the given command name.
   * @param {string} commandName - Name of the command to log help info.
   */
  help(commandName) {
    let command = this.interpreter.lookup(commandName);
    if (!command) {
      this.logger.error(`Command not found: "${commandName}"`);
      return;
    }
    this.logger.log(this.formatter.format(command.meta));
  }

  /**
   * Logs information about known traffic lights.
   */
  logInfo() {
    this.selector.logInfo(this.logger);
  }

}

////////////////////////////////////////////////

/**
 * Factory for a Commander that deals with a single physical traffic light.
 * It will get the first available traffic light for use.
 * @param {object} [options] - Commander options.
 * @param {object} [options.logger=console] - A Console-like object for logging,
 *   with a log and an error function.
 * @param {commands.MetaFormatter} [options.formatter] - A formatter for the help text of
 *   a command.
 * @param {commands.Interpreter} [options.interpreter] - The Command Interpreter to use.
 * @param {physical.DeviceManager} [options.manager] - The Device Manager to use.
 * @param {string|number} [options.serialNum] - The serial number of the
 *   traffic light to use, if available. Cleware USB traffic lights have
 *   a numeric serial number.
 * @returns {Commander} A single traffic light commander.
 */
Commander.single = (options = {}) => {
  const {SelectorCtor} = tryRequire('./selectors/physical-traffic-light-selector');
  const selector = new SelectorCtor(options);
  const commander = new Commander({...options, selector});
  commander.manager = selector.manager;
  return commander;
};

////////////////////////////////////////////////

/**
 * Factory for a Commander that deals with multiple physical traffic lights.
 * It will greedily get all available traffic lights for use.
 * @param {object} [options] - Commander options.
 * @param {object} [options.logger=console] - A Console-like object for logging,
 *   with a log and an error function.
 * @param {commands.MetaFormatter} [options.formatter] - A formatter for the help text of
 *   a command.
 * @param {commands.Interpreter} [options.interpreter] - The Command Interpreter to use.
 * @param {physical.DeviceManager} [options.manager] - The physical Device Manager to use.
 * @returns {Commander} A multiple traffic lights commander.
 */
Commander.multi = (options = {}) => {
  const {SelectorCtor} = tryRequire('./selectors/physical-multi-traffic-light-selector');
  const selector = new SelectorCtor(options);
  const commander = new Commander({...options, selector});
  commander.manager = selector.manager;
  return commander;
};

////////////////////////////////////////////////

module.exports = {Commander};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Sat Feb 15 2020 13:17:25 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
